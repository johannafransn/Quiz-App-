
{
  "questions": [{
    "q": "What is the best case for Insertion Sort?",
    "a": "O(logn)",
    "b": "O(nlogn)",
    "c": "O(n)",
    "d": "O(n^2)",
    "ans": "O(n)"
  },{
    "q": "What is the best case for Selection Sort?",
    "a": "O(1)",
    "b": "O(n^2)",
    "c": "O(logn)",
    "d": "O(n)",
    "ans": "O(n^2)"
  },{
    "q": "Which of these are FALSE regarding max heaps?",
    "a": "Parent node can not be smaller than children",
    "b": "The root node is the node with greatest value",
    "c": "The first node in the heap array is the largest",
    "d": "The last node in the heap array is the smallest.",
    "ans": "The last node in the heap array is the smallest."
  },{
    "q": "What is time complexity of building a n-node heap?",
    "a": "O(nlogn)",
    "b": "O(n)",
    "c": "O(logn)",
    "d": "O(1)",
    "ans": "O(nlogn)"
  },{

    "q": "What is time complexity of sorting n numbers using heapsort",
    "a": "O(nlogn)",
    "b": "O(n)",
    "c": "O(logn)",
    "d": "O(1)",
    "ans": "O(nlogn)"
  },{
    "q": "What are the minimum and maximum number of nodes in a heap of height h?",
    "a": "2^h and 2^(h+1)",
    "b": "2^h and 2^(h+1) – 1",
    "c": "2^h and 2^(h+1) + 1",
    "d": "2^h + 1 and 2^(h+1)",
    "ans": "2^h and 2^(h+1) - 1",
  },{
    "q": "What are the minimum and maximum number of nodes in a heap of height 5",
    "a": "32 and 65",
    "b": "33 and 64",
    "c": "32 and 63",
    "d": "31 and 64",
    "ans": "32 and 64",
  },{
    "q": "Which of the following is (are) correct?",
    "a": "The time complexity to heapify a random n-node binary tree (or n-number array) is O(n)",
    "b": "Heap sort is a stable sort. That is, operations on the heap will keep the relative order of equal items.",
    "c": "Heap sort is an in-place sort since no extra space, besides the given array, is used during the sorting.",
    "d": "None of these",
    "ans": "Heap sort is an in-place sort since no extra space, besides the given array, is used during the sorting.",
  },{
    "q": "Which of the following is TRUE about binary heaps and heapsort? ",
    "a": "Finding the maximum element in a min heap tree has a complexity of  O(log n)",
    "b": "Turning a random set of elements into a heap has a complexity of O(log n)",
    "c": "The worst-case time complexity of heapsort is O(n2).",
    "d": "Heapsort can be implemented with no additional space  ",
    "ans": "Heapsort can be implemented with no additional space  ",
  },{
    "q": "Which of the following is true according to this BST property?",
    "a": "The largest element is the right-most element",
    "b": "The largest element is the root node.",
    "c": "The largest element is the last element (the right-most element on the bottom level)",
    "d": "The largest element is the left-most element",
    "ans": "The largest element is the right-most element",
  },{
    "q": "What is time complexity of buiding an n-node Binary Search Tree in the worst & best case?",
    "a": "best case: O(n log n),  and worst case: O(n log n)",
    "b": "best case: O(n),  and worst case: O(n log n)",
    "c": "best case: O(nlog n),  and worst case: O(n^2)",
    "d": "best case: O(n),  and worst case: O(n^2)",
    "ans": "best case: O(nlog n),  and worst case: O(n^2)",
  },{
    "q": "What are the max and min number of nodes in a binary search tree of height 3? ",
    "a": "max =  16,     min = 4",
    "b": "max =   7,     min = 3",
    "c": "max =   8,     min = 3",
    "d": "max = 15,     min =  4",
    "ans": "max = 15,     min =  4",
  },{
    "q": "What are the max and min number of nodes in a binary search tree of height h",
    "a": "max = 2^(h+1)-1, min = h+1",
    "b": "max = 2^(h+1)+1, min = h+1",
    "c": "max = 2^(h-1), min = h-1",
    "d": "None of these",
    "ans": "max = 2^(h+1)-1, min = h+1",
  },{
    "q": "Which of the following is true about Heap vs Binary Search Tree?",
    "a": "BST tree traversal is slower than BST tree construction by the recursive insertions.",
    "b": "Heapsort has the same time complexity in the best case and worst case.",
    "c": "Sorting with BST has the same time complexity in the best case and worst case.",
    "d": "None of these",
    "ans": "Heapsort has the same time complexity in the best case and worst case.",
  },{
    "q": "The smallest and the largest keys in an AVL tree can always be found on ",
    "a": "Only the  last level",
    "b": "Only the  last two levels",
    "c": "Only the  last three levels",
    "d": "All the levels",
    "ans": "All the levels",
  },{
    "q": "Which of the following is false?",
    "a": "Red Black trees are absolutely balanced or at least ‘almost’ balanced.",
    "b": "In a Red-Black tree, there are equal numbers of red and black nodes.",
    "c": "Every path from root to a leaf (or to a null child) must contain the same number of black nodes",
    "d": "In a Red Black tree, every node is either red or black.",
    "ans": "In a Red-Black tree, there are equal numbers of red and black nodes.",
  },{
    "q": "In a Red-Black tree, newly inserted nodes are always colored:",
    "a": "black",
    "b": "The same color as parent node",
    "c": "red",
    "d": "The opposite color of parent node",
    "ans": "red",
  },{
    "q": "How many wrapper classes are there?",
    "a": "1",
    "b": "8",
    "c": "3",
    "d": "10",
    "ans": "8",
  },{
    "q": "What is an external sorting algorithm?",
    "a": "Algorithm that uses tape or disk during the sort",
    "b": "Algorithm that uses main memory during the sort",
    "c": "Algorithm that uses comparison based sorting",
    "d": "None of these",
    "ans": "Algorithm that uses tape or disk during the sort",
  },{
    "q": "What is an internal sorting algorithm?",
    "a": "Algorithm that uses tape or disk during the sort",
    "b": "Algorithm that uses main memory during the sort",
    "c": "Algorithm that uses comparison based sorting",
    "d": "None of these",
    "ans": "Algorithm that uses main memory during the sort",
  },{
    "q": "In the following scenarios, when will you use selection sort?",
    "a": "Large values need to be sorted with small keys",
    "b": "Small values need to be sorted with large keys",
    "c": "When the array is already sorted in ascending order",
    "d": "When the array is already sorted in descending order",
    "ans": "Large values need to be sorted with small keys"

  }
  ]
}